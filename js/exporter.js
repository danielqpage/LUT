/**
 * Export Module
 * Handles file generation and export functionality
 */

const exporter = {
    /**
     * Generate .cube LUT file content
     * @param {Array} lutData - 3D LUT data array
     * @param {number} lutSize - Size of the LUT (17, 33, 65)
     * @param {Object} metadata - Metadata about the LUT generation
     * @returns {string} .cube file content
     */
    generateCubeFile: (lutData, lutSize, metadata = {}) => {
        console.log(`Generating .cube file: ${lutSize}³ LUT with ${lutData.length} entries`);
        
        const {
            referenceColors = [],
            cameraColors = [],
            mode = 'standard',
            rangeData = null,
            filename = 'color_calibration',
            creator = 'Professional Color Chart LUT Generator',
            version = `${CONFIG.VERSION.major}.${CONFIG.VERSION.minor}.${CONFIG.VERSION.patch}`
        } = metadata;

        const lines = [];
        
        // File header with metadata
        lines.push('# Generated by Professional Color Chart LUT Generator');
        lines.push(`# Version: ${version}`);
        lines.push(`# Date: ${new Date().toISOString()}`);
        lines.push(`# Generator: ${creator}`);
        lines.push('');
        
        // LUT configuration metadata
        lines.push('# LUT Configuration');
        lines.push(`# Mode: ${exporter.getModeDescription(mode)}`);
        lines.push(`# Grid: ${CONFIG.GRID.cols}x${CONFIG.GRID.rows} with 9-point calibration`);
        lines.push(`# Color patches analyzed: ${referenceColors.length}`);
        lines.push(`# Sample size per patch: ${CONFIG.GRID.sampleSize}px`);
        lines.push(`# Sub-sampling grid: ${CONFIG.GRID.subSampleGrid}x${CONFIG.GRID.subSampleGrid}`);
        lines.push('');
        
        // Algorithm-specific metadata
        if (mode in lutGenerator.algorithms) {
            const algorithmInfo = lutGenerator.algorithms[mode];
            lines.push(`# Algorithm: ${algorithmInfo.name}`);
            lines.push(`# Description: ${algorithmInfo.description}`);
        }
        lines.push('');
        
        // Range analysis metadata (if applicable)
        if (rangeData) {
            lines.push('# Dynamic Range Analysis');
            lines.push(`# Reference range: ${rangeData.refRange.robustMin.toFixed(4)} - ${rangeData.refRange.robustMax.toFixed(4)}`);
            lines.push(`# Camera range: ${rangeData.camRange.robustMin.toFixed(4)} - ${rangeData.camRange.robustMax.toFixed(4)}`);
            lines.push(`# Range ratio: ${rangeData.rangeRatio.toFixed(4)}`);
            lines.push(`# Luminance offset: ${rangeData.luminanceOffset.toFixed(4)}`);
            lines.push(`# Compatibility: ${rangeData.compatibility.rating} (${(rangeData.compatibility.score * 100).toFixed(1)}%)`);
            lines.push('');
        }
        
        // Quality statistics
        if (metadata.qualityStats) {
            const { refStats, camStats } = metadata.qualityStats;
            lines.push('# Quality Statistics');
            lines.push(`# Reference patches: ${refStats.excellentPercent}% excellent, ${refStats.goodPercent}% good`);
            lines.push(`# Camera patches: ${camStats.excellentPercent}% excellent, ${camStats.goodPercent}% good`);
            lines.push(`# Average CV: Reference ${(refStats.avgCV * 100).toFixed(2)}%, Camera ${(camStats.avgCV * 100).toFixed(2)}%`);
            lines.push('');
        }
        
        // Technical specifications
        lines.push('# Technical Specifications');
        lines.push(`# Input color space: sRGB`);
        lines.push(`# Output color space: sRGB`);
        lines.push(`# Interpolation: ${mode === 'tetrahedral' ? 'Tetrahedral' : mode === 'perceptual' ? 'Lab-space' : 'Trilinear'}`);
        lines.push(`# Bit depth: 32-bit floating point`);
        lines.push('');
        
        // Usage instructions
        lines.push('# Usage Instructions');
        lines.push('# This LUT can be applied in video editing software, color grading tools,');
        lines.push('# or any application that supports .cube format LUTs.');
        lines.push('# Apply this LUT to camera footage to match the reference color chart.');
        lines.push('');
        
        // Standard .cube format headers
        lines.push(`LUT_3D_SIZE ${lutSize}`);
        lines.push('DOMAIN_MIN 0.0 0.0 0.0');
        lines.push('DOMAIN_MAX 1.0 1.0 1.0');
        lines.push('');
        
        // Validate LUT data
        if (!lutData || lutData.length !== lutSize * lutSize * lutSize) {
            throw new Error(`Invalid LUT data: expected ${lutSize}³ = ${lutSize * lutSize * lutSize} entries, got ${lutData?.length || 0}`);
        }
        
        // LUT data entries
        lutData.forEach((color, index) => {
            if (!utils.isValidColor(color)) {
                console.warn(`Invalid color at index ${index}:`, color);
                // Use a safe fallback
                color = [0.5, 0.5, 0.5];
            }
            
            // Format with 6 decimal places for precision
            const r = utils.clamp(color[0]).toFixed(6);
            const g = utils.clamp(color[1]).toFixed(6);
            const b = utils.clamp(color[2]).toFixed(6);
            lines.push(`${r} ${g} ${b}`);
        });
        
        const content = lines.join('\n');
        console.log(`Generated .cube file: ${lines.length} lines, ${content.length} characters`);
        
        return content;
    },

    /**
     * Get human-readable description for LUT mode
     * @param {string} mode - LUT generation mode
     * @returns {string} Mode description
     */
    getModeDescription: (mode) => {
        const descriptions = {
            'standard': 'Standard Color Matching',
            'rangeAware': 'Dynamic Range Optimization',
            'tetrahedral': 'Tetrahedral Interpolation',
            'perceptual': 'Perceptual Lab Space'
        };
        return descriptions[mode] || mode;
    },

    /**
     * Export analysis data as CSV
     * @param {Object} analysisData - Analysis data object
     * @returns {string} CSV content
     */
    exportAnalysisCSV: (analysisData) => {
        console.log('Generating analysis CSV export');
        
        const {
            referencePatches,
            cameraPatches,
            referenceQuality,
            cameraQuality,
            rangeData,
            skippedIndices = []
        } = analysisData;

        const { rows, cols } = CONFIG.GRID;
        const csv = [];
        
        // CSV Header
        let header = [
            'Patch_ID',
            'Type',
            'Row',
            'Col',
            'Grid_Position',
            'R',
            'G',
            'B',
            'Luminance',
            'CV_Percent',
            'Quality_Rating',
            'Quality_Score'
        ];
        
        if (rangeData) {
            header.push(
                'Luminance_Range',
                'Range_Position',
                'Mapped_Luminance'
            );
        }
        
        csv.push(header.join(','));
        
        // Process each grid position
        let patchIndex = 0;
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const gridIndex = row * cols + col;
                const gridPosition = `R${row + 1}C${col + 1}`;
                
                if (utils.isMarkerPosition(row, col)) {
                    // Marker position
                    const markerRow = [
                        gridIndex + 1,
                        'Marker',
                        row + 1,
                        col + 1,
                        gridPosition,
                        '-', '-', '-', '-', '-', 'Calibration_Marker', '-'
                    ];
                    
                    if (rangeData) {
                        markerRow.push('-', '-', '-');
                    }
                    
                    csv.push(markerRow.join(','));
                    continue;
                }
                
                // Color patch data
                const refColor = referencePatches[patchIndex];
                const camColor = cameraPatches[patchIndex];
                const refCV = referenceQuality[patchIndex];
                const camCV = cameraQuality[patchIndex];
                
                // Calculate additional metrics
                const refLuminance = utils.getLuminance(refColor);
                const camLuminance = utils.getLuminance(camColor);
                
                const refQualityInfo = utils.getQualityInfo(refCV);
                const camQualityInfo = utils.getQualityInfo(camCV);
                
                // Reference patch row
                let refRow = [
                    gridIndex + 1,
                    'Reference',
                    row + 1,
                    col + 1,
                    gridPosition,
                    refColor[0].toFixed(6),
                    refColor[1].toFixed(6),
                    refColor[2].toFixed(6),
                    refLuminance.toFixed(6),
                    (refCV * 100).toFixed(2),
                    refQualityInfo.description,
                    refQualityInfo.level
                ];
                
                // Camera patch row
                let camRow = [
                    gridIndex + 1,
                    'Camera',
                    row + 1,
                    col + 1,
                    gridPosition,
                    camColor[0].toFixed(6),
                    camColor[1].toFixed(6),
                    camColor[2].toFixed(6),
                    camLuminance.toFixed(6),
                    (camCV * 100).toFixed(2),
                    camQualityInfo.description,
                    camQualityInfo.level
                ];
                
                // Add range data if available
                if (rangeData) {
                    const refRange = rangeData.refRange;
                    const camRange = rangeData.camRange;
                    
                    const refRangePos = (refLuminance - refRange.robustMin) / refRange.range;
                    const camRangePos = (camLuminance - camRange.robustMin) / camRange.range;
                    
                    const mappedLuminance = (refLuminance * rangeData.rangeRatio) + rangeData.luminanceOffset;
                    
                    refRow.push(
                        `${refRange.robustMin.toFixed(3)}-${refRange.robustMax.toFixed(3)}`,
                        refRangePos.toFixed(4),
                        mappedLuminance.toFixed(6)
                    );
                    
                    camRow.push(
                        `${camRange.robustMin.toFixed(3)}-${camRange.robustMax.toFixed(3)}`,
                        camRangePos.toFixed(4),
                        camLuminance.toFixed(6)
                    );
                }
                
                csv.push(refRow.join(','));
                csv.push(camRow.join(','));
                
                patchIndex++;
            }
        }
        
        // Summary statistics section
        csv.push('');
        csv.push('# Summary Statistics');
        csv.push('Type,Total_Patches,Excellent,Good,Poor,Avg_CV_Percent,Quality_Score');
        
        const refStats = visualization.calculateQualityStats(referenceQuality);
        const camStats = visualization.calculateQualityStats(cameraQuality);
        
        csv.push([
            'Reference',
            refStats.total,
            refStats.excellent,
            refStats.good,
            refStats.poor,
            (refStats.avgCV * 100).toFixed(2),
            refStats.goodPercent
        ].join(','));
        
        csv.push([
            'Camera',
            camStats.total,
            camStats.excellent,
            camStats.good,
            camStats.poor,
            (camStats.avgCV * 100).toFixed(2),
            camStats.goodPercent
        ].join(','));
        
        // Range analysis summary
        if (rangeData) {
            csv.push('');
            csv.push('# Range Analysis Summary');
            csv.push('Metric,Reference,Camera,Ratio_or_Difference');
            csv.push(`Min_Luminance,${rangeData.refRange.robustMin.toFixed(4)},${rangeData.camRange.robustMin.toFixed(4)},${(rangeData.camRange.robustMin - rangeData.refRange.robustMin).toFixed(4)}`);
            csv.push(`Max_Luminance,${rangeData.refRange.robustMax.toFixed(4)},${rangeData.camRange.robustMax.toFixed(4)},${(rangeData.camRange.robustMax - rangeData.refRange.robustMax).toFixed(4)}`);
            csv.push(`Range_Span,${rangeData.refRange.range.toFixed(4)},${rangeData.camRange.range.toFixed(4)},${rangeData.rangeRatio.toFixed(4)}`);
            csv.push(`Mean_Luminance,${rangeData.refRange.mean.toFixed(4)},${rangeData.camRange.mean.toFixed(4)},${(rangeData.camRange.mean - rangeData.refRange.mean).toFixed(4)}`);
            csv.push(`Compatibility_Score,${rangeData.compatibility.score.toFixed(3)},${rangeData.compatibility.rating},-`);
        }
        
        // Generation metadata
        csv.push('');
        csv.push('# Generation Metadata');
        csv.push(`Generated_Date,${new Date().toISOString()}`);
        csv.push(`Generator_Version,${CONFIG.VERSION.major}.${CONFIG.VERSION.minor}.${CONFIG.VERSION.patch}`);
        csv.push(`Grid_Configuration,${CONFIG.GRID.cols}x${CONFIG.GRID.rows}`);
        csv.push(`Sample_Size,${CONFIG.GRID.sampleSize}px`);
        csv.push(`Sub_Sampling,${CONFIG.GRID.subSampleGrid}x${CONFIG.GRID.subSampleGrid}`);
        
        const content = csv.join('\n');
        console.log(`Generated analysis CSV: ${csv.length} lines, ${content.length} characters`);
        
        return content;
    },

    /**
     * Export alignment data as JSON
     * @param {string} imageType - Image type ('reference' or 'camera')
     * @param {Object} alignment - Alignment data
     * @returns {string} JSON content
     */
    exportAlignmentJSON: (imageType, alignment) => {
        const exportData = {
            version: `${CONFIG.VERSION.major}.${CONFIG.VERSION.minor}.${CONFIG.VERSION.patch}`,
            timestamp: new Date().toISOString(),
            imageType: imageType,
            gridConfiguration: {
                rows: CONFIG.GRID.rows,
                cols: CONFIG.GRID.cols,
                sampleSize: CONFIG.GRID.sampleSize
            },
            markers: alignment.markers.map(marker => ({
                index: marker.index,
                name: marker.markerInfo.name,
                gridPosition: marker.markerInfo.gridPos,
                imageCoordinates: {
                    x: marker.imageX,
                    y: marker.imageY
                },
                timestamp: marker.timestamp
            })),
            quality: alignment.quality,
            isComplete: alignment.isComplete
        };
        
        return JSON.stringify(exportData, null, 2);
    },

    /**
     * Import alignment data from JSON
     * @param {string} jsonContent - JSON content string
     * @returns {Object} Parsed alignment data
     */
    importAlignmentJSON: (jsonContent) => {
        try {
            const data = JSON.parse(jsonContent);
            
            // Validate basic structure
            if (!data.markers || !Array.isArray(data.markers)) {
                throw new Error('Invalid alignment data: missing markers array');
            }
            
            if (data.markers.length !== CONFIG.MARKERS.length) {
                throw new Error(`Invalid alignment data: expected ${CONFIG.MARKERS.length} markers, found ${data.markers.length}`);
            }
            
            // Reconstruct marker objects
            const markers = data.markers.map(markerData => ({
                index: markerData.index,
                imageX: markerData.imageCoordinates.x,
                imageY: markerData.imageCoordinates.y,
                markerInfo: CONFIG.MARKERS[markerData.index],
                timestamp: markerData.timestamp || Date.now()
            }));
            
            return {
                imageType: data.imageType,
                markers: markers,
                quality: data.quality,
                isComplete: data.isComplete,
                timestamp: data.timestamp
            };
            
        } catch (error) {
            throw new Error(`Failed to import alignment data: ${error.message}`);
        }
    },

    /**
     * Export project data (complete session state)
     * @param {Object} projectData - Complete project data
     * @returns {string} JSON project file content
     */
    exportProject: (projectData = {}) => {
        const {
            referenceImageInfo = null,
            cameraImageInfo = null,
            alignments = state.alignments,
            lutMode = state.lutMode,
            analysisData = state.analysisData,
            rangeData = state.rangeData,
            settings = {}
        } = projectData;
        
        const project = {
            version: `${CONFIG.VERSION.major}.${CONFIG.VERSION.minor}.${CONFIG.VERSION.patch}`,
            timestamp: new Date().toISOString(),
            type: 'LUT_Generator_Project',
            
            images: {
                reference: referenceImageInfo ? {
                    name: referenceImageInfo.name,
                    size: referenceImageInfo.size,
                    type: referenceImageInfo.type,
                    dimensions: {
                        width: referenceImageInfo.width,
                        height: referenceImageInfo.height
                    }
                } : null,
                camera: cameraImageInfo ? {
                    name: cameraImageInfo.name,
                    size: cameraImageInfo.size,
                    type: cameraImageInfo.type,
                    dimensions: {
                        width: cameraImageInfo.width,
                        height: cameraImageInfo.height
                    }
                } : null
            },
            
            alignments: {
                reference: alignments.reference.isComplete ? {
                    markers: alignments.reference.markers.map(m => ({
                        index: m.index,
                        imageX: m.imageX,
                        imageY: m.imageY,
                        timestamp: m.timestamp
                    })),
                    quality: alignments.reference.quality,
                    timestamp: alignments.reference.timestamp
                } : null,
                camera: alignments.camera.isComplete ? {
                    markers: alignments.camera.markers.map(m => ({
                        index: m.index,
                        imageX: m.imageX,
                        imageY: m.imageY,
                        timestamp: m.timestamp
                    })),
                    quality: alignments.camera.quality,
                    timestamp: alignments.camera.timestamp
                } : null
            },
            
            lutConfiguration: {
                mode: lutMode,
                algorithms: Object.keys(lutGenerator.algorithms),
                selectedSize: parseInt(document.getElementById('lutSize')?.value || CONFIG.LUT.defaultSize)
            },
            
            analysis: analysisData ? {
                patchCount: analysisData.referencePatches?.length || 0,
                qualityStats: {
                    reference: visualization.calculateQualityStats(analysisData.referenceQuality),
                    camera: visualization.calculateQualityStats(analysisData.cameraQuality)
                },
                hasRangeData: !!rangeData
            } : null,
            
            rangeAnalysis: rangeData ? {
                referenceRange: {
                    min: rangeData.refRange.robustMin,
                    max: rangeData.refRange.robustMax,
                    span: rangeData.refRange.range,
                    mean: rangeData.refRange.mean
                },
                cameraRange: {
                    min: rangeData.camRange.robustMin,
                    max: rangeData.camRange.robustMax,
                    span: rangeData.camRange.range,
                    mean: rangeData.camRange.mean
                },
                mapping: {
                    rangeRatio: rangeData.rangeRatio,
                    luminanceOffset: rangeData.luminanceOffset,
                    recommendedMode: rangeData.recommendedMode
                },
                compatibility: rangeData.compatibility
            } : null,
            
            settings: {
                visualization: state.visualization,
                gridConfig: CONFIG.GRID,
                qualityThresholds: CONFIG.QUALITY,
                ...settings
            }
        };
        
        return JSON.stringify(project, null, 2);
    },

    /**
     * Generate quality report
     * @param {Object} analysisData - Analysis data
     * @param {Object} rangeData - Range data (optional)
     * @returns {string} HTML report content
     */
    generateQualityReport: (analysisData, rangeData = null) => {
        const { referenceQuality, cameraQuality } = analysisData;
        const refStats = visualization.calculateQualityStats(referenceQuality);
        const camStats = visualization.calculateQualityStats(cameraQuality);
        
        const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Calibration Quality Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        .header { text-align: center; margin-bottom: 40px; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .stat-card { border: 1px solid #ddd; padding: 20px; border-radius: 8px; }
        .excellent { color: #059669; }
        .good { color: #d97706; }
        .poor { color: #dc2626; }
        .range-section { margin-top: 40px; padding: 20px; background: #f8fafc; border-radius: 8px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border: 1px solid #ddd; }
        th { background: #f1f5f9; }
        .timestamp { color: #6b7280; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Color Calibration Quality Report</h1>
        <p class="timestamp">Generated: ${new Date().toLocaleString()}</p>
        <p>Professional Color Chart LUT Generator v${CONFIG.VERSION.major}.${CONFIG.VERSION.minor}.${CONFIG.VERSION.patch}</p>
    </div>

    <h2>Quality Summary</h2>
    <div class="stats-grid">
        <div class="stat-card">
            <h3>Reference Chart</h3>
            <p><span class="excellent">${refStats.excellentPercent}%</span> Excellent patches</p>
            <p><span class="good">${refStats.goodPercent - refStats.excellentPercent}%</span> Good patches</p>
            <p><span class="poor">${100 - refStats.goodPercent}%</span> Poor patches</p>
            <p>Average CV: ${(refStats.avgCV * 100).toFixed(2)}%</p>
        </div>
        <div class="stat-card">
            <h3>Camera Capture</h3>
            <p><span class="excellent">${camStats.excellentPercent}%</span> Excellent patches</p>
            <p><span class="good">${camStats.goodPercent - camStats.excellentPercent}%</span> Good patches</p>
            <p><span class="poor">${100 - camStats.goodPercent}%</span> Poor patches</p>
            <p>Average CV: ${(camStats.avgCV * 100).toFixed(2)}%</p>
        </div>
    </div>

    ${rangeData ? `
    <div class="range-section">
        <h2>Dynamic Range Analysis</h2>
        <table>
            <tr>
                <th>Metric</th>
                <th>Reference</th>
                <th>Camera</th>
                <th>Difference/Ratio</th>
            </tr>
            <tr>
                <td>Luminance Range</td>
                <td>${rangeData.refRange.robustMin.toFixed(3)} - ${rangeData.refRange.robustMax.toFixed(3)}</td>
                <td>${rangeData.camRange.robustMin.toFixed(3)} - ${rangeData.camRange.robustMax.toFixed(3)}</td>
                <td>${rangeData.rangeRatio.toFixed(3)}×</td>
            </tr>
            <tr>
                <td>Mean Luminance</td>
                <td>${rangeData.refRange.mean.toFixed(3)}</td>
                <td>${rangeData.camRange.mean.toFixed(3)}</td>
                <td>${(rangeData.camRange.mean - rangeData.refRange.mean).toFixed(3)}</td>
            </tr>
            <tr>
                <td>Compatibility</td>
                <td colspan="2">${rangeData.compatibility.rating} (${(rangeData.compatibility.score * 100).toFixed(1)}%)</td>
                <td>${rangeData.compatibility.recommendation}</td>
            </tr>
        </table>
    </div>
    ` : ''}

    <h2>Quality Legend</h2>
    <table>
        <tr>
            <th>Rating</th>
            <th>CV Range</th>
            <th>Description</th>
        </tr>
        <tr class="excellent">
            <td>Excellent</td>
            <td>&lt; 5%</td>
            <td>Highly consistent color sampling</td>
        </tr>
        <tr class="good">
            <td>Good</td>
            <td>5% - 15%</td>
            <td>Acceptable color variation</td>
        </tr>
        <tr class="poor">
            <td>Poor</td>
            <td>&gt; 15%</td>
            <td>High inconsistency, may affect LUT quality</td>
        </tr>
    </table>

    <h2>Recommendations</h2>
    <ul>
        ${refStats.goodPercent < 80 ? '<li>Reference chart quality is suboptimal. Consider improving lighting or chart condition.</li>' : ''}
        ${camStats.goodPercent < 80 ? '<li>Camera capture quality could be improved. Check focus, lighting, and camera settings.</li>' : ''}
        ${rangeData && rangeData.compatibility.score < 0.6 ? '<li>Poor range compatibility detected. Use range-aware LUT generation mode.</li>' : ''}
        ${rangeData && Math.abs(rangeData.rangeRatio - 1.0) > 0.3 ? '<li>Significant exposure difference detected. Consider adjusting camera settings.</li>' : ''}
        <li>For best results, ensure consistent lighting between reference and camera captures.</li>
        <li>Verify that both images are properly focused and free from motion blur.</li>
    </ul>
</body>
</html>`;
        
        return html;
    },

    /**
     * Download file with given content
     * @param {string} content - File content
     * @param {string} filename - Filename
     * @param {string} mimeType - MIME type
     */
    downloadFile: (content, filename, mimeType = 'text/plain') => {
        ui.downloadFile(content, filename, mimeType);
        console.log(`Downloaded file: ${filename}`);
    }
};

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = exporter;
}